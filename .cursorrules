// Flutter App Expert .cursorrules

// Flexibility Notice

// Note: This is a recommended project structure, but be flexible and adapt to existing project structures.
// Do not enforce these structural patterns if the project follows a different organization.
// Focus on maintaining consistency with the existing project architecture while applying Flutter best practices.

// Flutter Best Practices

const flutterBestPractices = [
    "Adapt to existing project architecture while maintaining clean code principles",
    "Use Flutter 3.x features and Material 3 design",
    "Implement clean architecture with BLoC pattern",
    "Follow proper state management principles (BLoC/Cubit)",
    "Use proper dependency injection with GetIt",
    "Implement proper error handling with Either/Failure",
    "Follow platform-specific design guidelines",
    "Use proper localization techniques with easy_localization and JSON assets",
];

// Project Structure

// Note: This is a reference structure. Adapt to the project's existing organization

const projectStructure = `
lib/
  _core/
    error/
    layout/
      adaptive_layout/
    constants.dart
    theme.dart
    di.dart
    app_router.dart
    ...
  _shared/
    bloc/
    data/
      models/
    domain/
    features/
      feature_name/
        page/
        widgets/
    utils/
    widgets/
    shared_module.dart
    shared_routes.dart
  modules/
    module_name/
      bloc/
      data/
        models/
      domain/
      features/
        subfeature_name/
          bloc/
          page/
          widgets/
      auth_module.dart
      auth_routes.dart
      __tests__/
  generated/
  __tests__/
assets/
  images/
  svg/
  translations/
pubspec.yaml
README.md
`;

// Coding Guidelines

const codingGuidelines = `
1. Use proper null safety practices
2. Implement proper error handling with Either<Failure, T> (dartz)
3. Follow proper naming conventions
4. Use proper widget composition
5. Implement routing using GoRouter
6. Use proper form validation
7. Follow state management with BLoC/Cubit
8. Implement dependency injection using GetIt
9. Use proper asset management (images/svg/translations)
10. Organize code by feature/module for scalability
`;

// Widget Guidelines

const widgetGuidelines = `
1. Keep widgets small and focused
2. Use const constructors when possible
3. Implement proper widget keys
4. Follow proper layout principles (responsive/adaptive)
5. Use proper widget lifecycle methods
6. Implement error boundaries where needed
7. Optimize widget performance
8. Follow accessibility guidelines
`;

// Performance Guidelines

const performanceGuidelines = `
1. Use image caching where appropriate
2. Optimize list views and builders
3. Minimize rebuilds in build methods
4. Use BLoC/Cubit for efficient state management
5. Manage memory and resources properly
6. Use platform channels only when needed
7. Optimize for web, mobile, and desktop
`;

// Testing Guidelines

const testingTestingGuidelines = `
1. Write unit tests for business logic (placed in __tests__/ dans chaque module ou feature)
2. Use flutter_test and mocktail for mocking
3. Focus on repository, usecase, and bloc/cubit tests
4. Use proper test naming conventions
5. Ensure test coverage for critical paths
6. CI/CD integration recommended mais non impos√©
`;

// Project Specific Best Practices

const projectSpecificBestPractices = `
1. Implement conditional guards and redirects with GoRouter to secure access to routes based on authentication state or other business criteria.
2. Centralize the declaration of routes and navigation tabs through dependency injection (GetIt) to allow for modular and flexible configuration.
3. Use Hive for local persistence of user preferences (e.g., theme, token, user) and caches.
4. Manage language changes dynamically via easy_localization, using a dedicated widget (e.g., LanguageChangeButton) and ensuring the locale change occurs in the correct context (rootNavigatorKey).
5. Use .gitKeep files to force versioning of necessary empty directories for the project structure.
6. Place code generated by easy_localization in lib/generated/. If other generation tools are used, organize them in dedicated folders.
7. Place globally reusable widgets in _shared/widgets/ and feature/module-specific widgets in the corresponding feature/module directory.
8. Use streams for managing reactive states (e.g., connected user) to ensure UI synchronization with the business truth source.
9. Systematically make state and error classes inherit from Equatable to ensure reliable object comparison and optimize rebuilds.
10. Use the mocktail library for mocking in unit and integration tests.
`;

